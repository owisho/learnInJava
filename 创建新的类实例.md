新的类实例可以在类实例创建表达式的计算导致类被实例化时显式的创建。</br>
新的类实例可以在下列情况下隐式地创建：</br>
1.加载包含String字面常量的类或接口时，会创建新的String对象，用来表示该字面常量。</br>
2.执行会引发装箱类型转换的操作。装箱类型转换会创建与某种简单类型相关联的包装器类的新对象。</br>
3.执行不是常量表达式一部分的字符串操作符时，有事会创建新的String对象以表示执行结果。字符串连接操作符还可以为简单类型值创建临时的包装器对象。</br>
4.计算方法引用表达式或lambda表达式时，可能会要求创建实现了函数型接口类型的类的新实例。</br>
在将对新创建对象的引用当做结果返回之前，所表示的构造器会使用下面的过程来初始化该新对象：</br>
1）将构造器的引元赋值给新创建的用于该构造器调用的参数变量。</br>
2）如果该构造器以显示的对同一个类（使用this）中另一个构造器的调用开头，那么就会递归地使用这里描述的5个步骤去计算引元和处理构造器调用。如果该构造器调用猝然结束，那么整个过程也就医相同的原因猝然结束；否则，跳到步骤5继续。</br>
3）如果该构造器不是以显示的对同一个类（使用this）中类一个构造器的调用开头，那么如果该构造器用于Object之外的类，那么它将以显示的或隐式的对超类构造器（使用super）的调用开头。然后递归地使用这里描述的5个步骤去计算引元和处理构造器调用。如果该构造器调用猝然结束，那么整个过程也就以相同的原因猝然结束；否则，跳到步骤4继续。
4）执行该类的实例初始化器和实例鼻梁初始化器，按照在该类的源代码中的行文顺序，从左向右地将实例变量初始化器的值赋值给相应的实例变量。如果这些初始化器的任何一个在执行时产生了异常 ，那么其后的初始化器就不再处理了，并且整个过程也就以相同的原因猝然结束。否则，跳到步骤5继续。</br>
5）执行该构造器体的剩余部分。如果执行过程中猝然结束，那么真个过程也就以相同的原因猝然结束。否则，该过程正常结束。</br>
与C++不同，Java变成语言没有在新的类实例创建过程中为方法分派指定变更规则。如果被调用的方法在被初始化的对象所属的子类中被覆盖了，那么将会使用这些覆盖方法，即使是在心对象被完全初始化之前也是如此。
