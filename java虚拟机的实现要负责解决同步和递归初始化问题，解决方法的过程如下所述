该Class对象已经完成校验和准备，但是还没有被初始化。</br>
该Class对象正在由某个特定线程T初始化。</br>
该Class对象已经完成初始化，并可以使用了。</br>
该Class对象处理错误状态，可能是因为尝试进行初始化，但是失败了。</br>
对于每一个类或接口C，都有唯一的初始化锁LC。从C到LC的映射方式留给了Java虚拟机实现自行决定。然后，C将按照下面的过程初始化：</br>
1）在C的初始化锁LC上同步。这需要等待直至当前线程可以获取LC。</br>
2）如果C的Class对象表示某个其他线程正在初始化C，那么久释放LC，并阻塞当前线程，直到它被告知正在进行的初始化已经完成了，此时重复执行本步骤。</br>
3）如果C的Class对象表示当前线程正在初始化C，那么本次初始化就必然是递归的初始化请求，所以释放LC并正常的结束。</br>
4）如果C的Class对象表示C已经被初始化，那么就不需要更多的动作了，所以释放LC并正常地结束。</br>
5）如果C的Class对象表示C处于错误状态，那么初始化就不可能完成了，所以释放LC，并抛出NoClassDefFoundError的实例。</br>
6）否则，记录C的Class对象的初始化正在由当前线程处理这一事实，然后释放LC。然后，初始化C的static域，他们的值是常量变量。
7）接下来，如果C是类而不是接口，并且其超类SC还没有被初始化，那么递归地为SC执行这里描述的整个过程。如果必须，则要先校验和准备SC。</br>
如果SC的初始化因为抛出的异常而猝然结束，那么久获取LC、将C的Class对象标记为错误、通知所有等待的线程、释放LC，然后猝然结束，</br>
抛出从SC初始化中产生的异常。</br>
8）通过查询C的定义类加载器，确定是否启动断言。</br>
9）然后，执行类变量初始化器和类的静态初始化器，或者执行接口的域初始化器，执行时按照行文顺序，就像他们都在单个块中一样。</br>
10）如果初始化器的执行正常结束，那么就获取LC，将C的Class对象标记为完成初始化、通知所有等待的线程、释放LC，然后正常结束整个过程。</br>
11）否则，必然有初始化器通过抛出某个异常E而猝然结束了。如果E的类不是Error或其子类，那么就用E当做引元，创建一个ExceptionInInitializerError</br>
类的新实例，然后在下一个步骤中使用这个对象代替E。但是如果ExceptionInInitializerError的新实例因产生了OutOfMemoryError而不能创建，</br>
那么就在下一个步骤中使用OutOfMemoryError对象代替E。
12）获取LC、将C的Class对象标记为错误、通知所有等待的线程、释放LC，然后以E作为原因，或者以前一个步骤中确定的E的替代异常作为原因，猝然结束整个过程。
